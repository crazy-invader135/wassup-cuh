<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Neighbor - Grass Edition</title>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:Arial; }
        canvas { display:block; }
        #instructions, #gameOver {
            position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            background:rgba(0,0,0,0.85); color:white; padding:30px; border-radius:12px;
            text-align:center; z-index:100; max-width:420px;
        }
        #instructions.hidden { display:none; }
        #gameOver { color:red; display:none; font-size:1.8em; }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Sneak In!</h1>
        <p><strong>Click â†’ WASD + Mouse</strong><br>Sneak past the red neighbor!</p>
    </div>
    <div id="gameOver">
        <h1>CAUGHT!</h1>
        <p>Refresh to try again</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x228B22, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // === FIXED + BEAUTIFUL LIGHTING ===
        scene.add(new THREE.AmbientLight(0x666666, 1.4));
        const sun = new THREE.DirectionalLight(0xffffff, 1.4);
        sun.position.set(20, 40, 20);
        sun.castShadow = true;
        sun.shadow.mapSize.width = sun.shadow.mapSize.height = 2048;
        scene.add(sun);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));

        // === GRASS FLOOR WITH TEXTURE ===
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('Textures/Grass.png');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(30, 30); // makes it look nice and dense

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshLambertMaterial({ map: grassTexture })
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        // House (same as before)
        const wallMat = new THREE.MeshLambertMaterial({color:0xcd853f});
        const roofMat = new THREE.MeshLambertMaterial({color:0x8b4513});

        const box = (w,h,d,x,y,z) => {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
            m.position.set(x,y,z); m.castShadow = m.receiveShadow = true;
            scene.add(m); return m;
        };
        box(8.5,10,1, -5.75,5,-20);  // left front
        box(8.5,10,1,  5.75,5,-20);  // right front
        box(20,10,1, 0,5,20);        // back
        box(1,10,42,-10,5,0);        // left wall
        box(1,10,42, 10,5,0);        // right wall

        const roof = new THREE.Mesh(new THREE.BoxGeometry(22,2,44), roofMat);
        roof.position.set(0,11,0);
        roof.castShadow = roof.receiveShadow = true;
        scene.add(roof);

        // Neighbor
        const neighbor = new THREE.Mesh(
            new THREE.BoxGeometry(1.8,3.5,1.8),
            new THREE.MeshLambertMaterial({color:0xff0000})
        );
        neighbor.position.set(0,1.75,5);
        neighbor.castShadow = true;
        scene.add(neighbor);

        const patrolPoints = [
            new THREE.Vector3(0,1.75,5),
            new THREE.Vector3(6,1.75,12),
            new THREE.Vector3(-6,1.75,12),
            new THREE.Vector3(0,1.75,5)
        ];
        let idx = 0;

        camera.position.set(0,1.8,-30);

        // Controls (same as your working version)
        let yaw = 0, pitch = 0;
        const keys = {};
        addEventListener('keydown', e => keys[e.code] = true);
        addEventListener('keyup',   e => keys[e.code] = false);
        addEventListener('click', () => renderer.domElement.requestPointerLock());
        addEventListener('mousemove', e => {
            if (document.pointerLockElement) {
                yaw   -= e.movementX * 0.002;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-1.57, Math.min(1.57, pitch));
            }
        });

        // Simple collision
        const walls = scene.children.filter(o => o instanceof THREE.Mesh && o !== ground && o !== neighbor);
        function collides(pos) {
            const box = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(0.8,2.4,0.8));
            return walls.some(w => box.intersectsBox(new THREE.Box3().setFromObject(w)));
        }

        let gameOver = false;
        const instructions = document.getElementById('instructions');
        const gameOverDiv  = document.getElementById('gameOver');

        function animate() {
            requestAnimationFrame(animate);

            camera.rotation.set(pitch, yaw, 0);

            if (!gameOver) {
                const speed = 0.15;
                const move = new THREE.Vector3(
                    (keys['KeyD']?-speed:0) + (keys['KeyA']?speed:0),
                    0,
                    (keys['KeyW']?-speed:0) + (keys['KeyS']?speed:0)
                );
                if (move.lengthSq()) {
                    move.applyQuaternion(camera.quaternion);
                    const np = camera.position.clone().add(move);
                    if (!collides(np)) camera.position.copy(np);
                }

                // neighbor patrol
                const target = patrolPoints[idx];
                const dir = target.clone().sub(neighbor.position).normalize();
                neighbor.position.add(dir.multiplyScalar(0.025));
                neighbor.lookAt(target);
                if (neighbor.position.distanceTo(target) < 0.5) idx = (idx+1)%4;

                // detection
                if (camera.position.distanceTo(neighbor.position) < 12) {
                    const toPlayer = camera.position.clone().sub(neighbor.position).normalize();
                    neighbor.getWorldDirection(dir);
                    if (toPlayer.dot(dir.negate()) > 0.6) {
                        gameOver = true;
                        gameOverDiv.style.display = 'block';
                    }
                }

                // win
                if (camera.position.z > 18) {
                    alert('YOU WIN! You sneaked in!');
                    gameOver = true;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
    </script>
</body>
</html>
