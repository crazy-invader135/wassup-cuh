<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Neighbor-like Game</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 10px;
            z-index: 100;
            max-width: 400px;
        }
        #instructions.hidden {
            display: none;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 10px;
            z-index: 100;
            display: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Sneak In!</h1>
        <p><strong>Click to play</strong><br>
        Move: <strong>WASD</strong><br>
        Look: <strong>Mouse</strong><br><br>
        Sneak past the red neighbor into the house without being caught!</p>
    </div>
    <div id="gameOver">
        <h1>Caught!</h1>
        <p>Game Over. <strong>Refresh to restart</strong></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Basic setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x228B22, 20, 80);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Mouse look variables
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        let mouseX = 0, mouseY = 0;

        // Movement variables
        const moveSpeed = 0.15;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const direction = new THREE.Vector3();
        const vec = new THREE.Vector3();
        const rightVec = new THREE.Vector3();

        // Keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Mouse look
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                mouseX -= event.movementX * 0.002;
                mouseY -= event.movementY * 0.002;
                mouseY = Math.max(-PI_2, Math.min(PI_2, mouseY));
            }
        });

        // Pointer lock
        const instructions = document.getElementById('instructions');
        const gameOverDiv = document.getElementById('gameOver');
        document.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
            instructions.classList.add('hidden');
        });
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== renderer.domElement) {
                instructions.classList.remove('hidden');
            }
        });

        // GROUND â€” ONLY CHANGE HERE
        const loader = new THREE.TextureLoader();
        const grassTexture = loader.load('Textures/Grass.png');
        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(25, 25);

        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ map: grassTexture });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        // END OF CHANGE

        // House walls (exactly the same as before)
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const leftFrontWall = new THREE.Mesh(new THREE.BoxGeometry(8.5, 10, 1), wallMaterial);
        leftFrontWall.position.set(-5.75, 5, -20);
        leftFrontWall.castShadow = true;
        leftFrontWall.receiveShadow = true;
        scene.add(leftFrontWall);

        const rightFrontWall = new THREE.Mesh(new THREE.BoxGeometry(8.5, 10, 1), wallMaterial);
        rightFrontWall.position.set(5.75, 5, -20);
        rightFrontWall.castShadow = true;
        rightFrontWall.receiveShadow = true;
        scene.add(rightFrontWall);

        const backWall = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 1), wallMaterial);
        backWall.position.set(0, 5, 20);
        backWall.castShadow = true;
        backWall.receiveShadow = true;
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 40), wallMaterial);
        leftWall.position.set(-10, 5, 0);
        leftWall.castShadow = true;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 10, 40), wallMaterial);
        rightWall.position.set(10, 5, 0);
        rightWall.castShadow = true;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
        const roof = new THREE.Mesh(new THREE.BoxGeometry(22, 1, 42), roofMaterial);
        roof.position.set(0, 10.5, 0);
        roof.castShadow = true;
        roof.receiveShadow = true;
        scene.add(roof);

        // Lighting (your original)
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 20, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        scene.add(directionalLight);

        // Neighbor
        const neighborGeometry = new THREE.BoxGeometry(1.8, 3.5, 1.8);
        const neighborMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const neighbor = new THREE.Mesh(neighborGeometry, neighborMaterial);
        neighbor.position.set(0, 1.75, 5);
        neighbor.castShadow = true;
        scene.add(neighbor);

        // Patrol points
        const patrolPoints = [
            {pos: new THREE.Vector3(0, 1.75, 5)},
            {pos: new THREE.Vector3(6, 1.75, 12)},
            {pos: new THREE.Vector3(-6, 1.75, 12)},
            {pos: new THREE.Vector3(0, 1.75, 5)}
        ];
        let currentPatrolIndex = 0;
        const patrolSpeed = 0.025;

        // Collision walls
        const walls = [leftFrontWall, rightFrontWall, backWall, leftWall, rightWall, roof];

        // Player start
        camera.position.set(0, 1.8, -30);

        // Collision detection (your original)
        const playerSize = 0.4;
        function checkCollision(position) {
            const playerMin = new THREE.Vector3(position.x - playerSize, position.y - 1.2, position.z - playerSize);
            const playerMax = new THREE.Vector3(position.x + playerSize, position.y + 0.6, position.z + playerSize);
            const playerBox = new THREE.Box3(playerMin, playerMax);
            for (let wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) return true;
            }
            if (position.y < 1.2) return true;
            return false;
        }

        // Game state
        let gameOver = false;
        let won = false;

        // Animate
        function animate() {
            requestAnimationFrame(animate);

            euler.set(mouseY, mouseX, 0);
            camera.quaternion.setFromEuler(euler);

            if (!gameOver && !won) {
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (direction.length() > 0) {
                    camera.getWorldDirection(vec);
                    vec.y = 0;
                    vec.normalize();
                    rightVec.crossVectors(vec, new THREE.Vector3(0, 1, 0)).normalize();
                    const velocityX = direction.x * moveSpeed;
                    const velocityZ = direction.z * moveSpeed;
                    const moveVec = new THREE.Vector3();
                    moveVec.addScaledVector(rightVec, velocityX);
                    moveVec.addScaledVector(vec, velocityZ);
                    const proposedPosition = camera.position.clone().add(moveVec);
                    if (!checkCollision(proposedPosition)) {
                        camera.position.copy(proposedPosition);
                    }
                }

                // Neighbor patrol
                const target = patrolPoints[currentPatrolIndex].pos;
                const moveDir = target.clone().sub(neighbor.position).normalize();
                neighbor.position.add(moveDir.multiplyScalar(patrolSpeed));
                const targetPos = target.clone();
                targetPos.y = neighbor.position.y;
                neighbor.lookAt(targetPos);
                if (neighbor.position.distanceTo(target) < 0.3) {
                    currentPatrolIndex = (currentPatrolIndex + 1) % patrolPoints.length;
                }

                // Detection
                const dist = camera.position.distanceTo(neighbor.position);
                if (dist < 12) {
                    const toPlayer = camera.position.clone().sub(neighbor.position).normalize();
                    neighbor.getWorldDirection(vec);
                    if (toPlayer.dot(vec) > 0.6) {
                        gameOver = true;
                        gameOverDiv.style.display = 'block';
                    }
                }

                // Win condition
                if (camera.position.z > 18 && Math.abs(camera.position.x) < 8) {
                    won = true;
                    alert('You sneaked in! You win! Refresh to play again.');
                }
            }

            renderer.render(scene, camera);
        }

        if (!renderer.capabilities.isWebGL2 && !renderer.capabilities.isWebGL1) {
            document.body.innerHTML = '<h1 style="color:red;text-align:center;padding:50px;">WebGL not supported. Try Chrome/Firefox/Edge.</h1>';
        } else {
            animate();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
