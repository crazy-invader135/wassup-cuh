<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hello Neighbor Floor with Walls & Collision</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #instructions {
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: Arial, sans-serif;
    font-size: 24px;
    cursor: pointer;
  }
</style>
</head>
<body>
<div id="instructions">Click to play</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/PointerLockControls.js"></script>

<script>
// Scene
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Camera
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 10);

// Renderer
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(5,10,5);
scene.add(dirLight);

// Floor texture
const loader = new THREE.TextureLoader();
const floorTexture = loader.load('Textures/Grass.png');
floorTexture.wrapS = THREE.RepeatWrapping;
floorTexture.wrapT = THREE.RepeatWrapping;
floorTexture.repeat.set(10,10);

const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(50,50),
  new THREE.MeshStandardMaterial({ map: floorTexture })
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// Walls
const wallMat = new THREE.MeshStandardMaterial({color:0x8B4513});
let walls = [];
function addWall(x,z,w,h,d){
  const wall = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
  wall.position.set(x,h/2,z);
  scene.add(wall);
  walls.push(wall);
}
// Surrounding walls
addWall(0,-25,50,3,1); // back
addWall(0,25,50,3,1);  // front
addWall(-25,0,1,3,50); // left
addWall(25,0,1,3,50);  // right

// PointerLockControls
const controls = new THREE.PointerLockControls(camera, renderer.domElement);
const instructions = document.getElementById('instructions');
instructions.addEventListener('click', () => { controls.lock(); });
controls.addEventListener('lock', () => { instructions.style.display='none'; });
controls.addEventListener('unlock', () => { instructions.style.display='flex'; });
scene.add(controls.getObject());

// Movement
const move = { forward:false, backward:false, left:false, right:false };
document.addEventListener('keydown', e=>{
  if(e.code==='KeyW') move.forward=true;
  if(e.code==='KeyS') move.backward=true;
  if(e.code==='KeyA') move.left=true;
  if(e.code==='KeyD') move.right=true;
});
document.addEventListener('keyup', e=>{
  if(e.code==='KeyW') move.forward=false;
  if(e.code==='KeyS') move.backward=false;
  if(e.code==='KeyA') move.left=false;
  if(e.code==='KeyD') move.right=false;
});

// Collision detection
function checkCollision(pos){
  const radius = 0.5; // player radius
  for(const wall of walls){
    const dx = Math.max(wall.position.x - wall.geometry.parameters.width/2, Math.min(pos.x, wall.position.x + wall.geometry.parameters.width/2));
    const dz = Math.max(wall.position.z - wall.geometry.parameters.depth/2, Math.min(pos.z, wall.position.z + wall.geometry.parameters.depth/2));
    const distance = Math.hypot(pos.x - dx, pos.z - dz);
    if(distance < radius) return true;
  }
  return false;
}

// Animate
const playerSpeed = 0.1;
function animate(){
  requestAnimationFrame(animate);

  const direction = new THREE.Vector3();
  if(move.forward) direction.z -= playerSpeed;
  if(move.backward) direction.z += playerSpeed;
  if(move.left) direction.x -= playerSpeed;
  if(move.right) direction.x += playerSpeed;

  // Proposed new position
  const newPos = controls.getObject().position.clone();
  newPos.x += direction.x;
  newPos.z += direction.z;

  // Check collisions
  if(!checkCollision(newPos)){
    controls.moveRight(direction.x);
    controls.moveForward(direction.z);
  }

  renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
