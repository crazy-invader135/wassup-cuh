<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Grass World – Perfect Collision (Actually Works)</title>
<style>
  body { margin:0; overflow:hidden; }
  #info { position:absolute; top:20px; left:20px; color:#fff; background:#0009; padding:15px; border-radius:10px; font-family:Arial; pointer-events:none; }
</style>
</head>
<body>
<div id="info">Click once → WASD to move. Try the wall!</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88ccff);
scene.fog = new THREE.Fog(0x88ccff, 100, 1500);

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const controls = new PointerLockControls(camera, document.body);
scene.add(controls.getObject());

document.body.addEventListener('click', () => controls.lock(), {once:true});

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(100,200,100);
sun.castShadow = true;
scene.add(sun);

// Grass
const tex = new THREE.TextureLoader().load('Textures/Grass.png');
tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
tex.repeat.set(1000,1000);
tex.encoding = THREE.sRGBEncoding;

const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(100000,100000),
  new THREE.MeshStandardMaterial({map:tex, roughness:0.9})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// WALL
const wall = new THREE.Mesh(
  new THREE.BoxGeometry(60, 30, 6),
  new THREE.MeshStandardMaterial({color:0x777777})
);
wall.position.set(0, 15, -50);
wall.castShadow = true;
wall.receiveShadow = true;
scene.add(wall);

const wallBox = new THREE.Box3().setFromObject(wall);

// Player
camera.position.y = 10;
const PLAYER_RADIUS = 3;

// Input
const move = {forward:false, backward:false, left:false, right:false};

document.addEventListener('keydown', e => {
  if(e.code==='KeyW') move.forward  = true;
  if(e.code==='KeyS') move.backward = true;
  if(e.code==='KeyA') move.left     = true;
  if(e.code==='KeyD') move.right    = true;
});
document.addEventListener('keyup', e => {
  if(e.code==='KeyW') move.forward  = false;
  if(e.code==='KeyS') move.backward = false;
  if(e.code==='KeyA') move.left     = false;
  if(e.code==='KeyD') move.right    = false;
});

function animate() {
  requestAnimationFrame(animate);

  if (!controls.isLocked) {
    renderer.render(scene, camera);
    return;
  }

  const speed = 150; // units per second
  const delta = 0.016; // ~60fps

  // Reset movement
  let dx = 0, dz = 0;

  if (move.forward)  dz -= speed * delta;
  if (move.backward) dz += speed * delta;
  if (move.right)    dx += speed * delta;
  if (move.left)     dx -= speed * delta;

  const pos = controls.getObject().position;

  // Test X movement
  const testBoxX = new THREE.Box3(
    new THREE.Vector3(pos.x + dx - PLAYER_RADIUS, pos.y, pos.z - PLAYER_RADIUS),
    new THREE.Vector3(pos.x + dx + PLAYER_RADIUS, pos.y + 6, pos.z + PLAYER_RADIUS)
  );
  if (!testBoxX.intersectsBox(wallBox)) {
    controls.moveRight(dx);
  }

  // Test Z movement (using updated X position)
  const testBoxZ = new THREE.Box3(
    new THREE.Vector3(pos.x - PLAYER_RADIUS, pos.y, pos.z + dz - PLAYER_RADIUS),
    new THREE.Vector3(pos.x + PLAYER_RADIUS, pos.y + 6, pos.z + dz + PLAYER_RADIUS)
  );
  if (!testBoxZ.intersectsBox(wallBox)) {
    controls.moveForward(dz);
  }

  pos.y = 10;
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
